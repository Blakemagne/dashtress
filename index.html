<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mattress Sales Dashboard</title>
    
    <!-- Load necessary libraries from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/recharts@2.11.0/umd/Recharts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lucide-react@0.264.0/dist/umd/lucide-react.min.js"></script>
    
    <style>
        :root {
            --primary: #1e40af;
            --primary-light: #3b82f6;
            --primary-dark: #1e3a8a;
            --secondary: #0f766e;
            --danger: #dc2626;
            --success: #16a34a;
            --warning: #ea580c;
            --info: #0891b2;
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #9ca3af;
            --gray-500: #6b7280;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
            --shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
            --rounded-sm: 0.25rem;
            --rounded: 0.5rem;
            --rounded-lg: 0.75rem;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        
        body {
            background-color: var(--gray-50);
            color: var(--gray-800);
            line-height: 1.5;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }
        
        /* Buttons */
        .btn {
            display: inline-block;
            padding: 0.5rem 1rem;
            border-radius: var(--rounded-sm);
            font-weight: 500;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-primary {
            background-color: var(--primary);
            color: white;
            border: 1px solid var(--primary);
        }
        
        .btn-primary:hover {
            background-color: var(--primary-dark);
            border-color: var(--primary-dark);
        }
        
        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--gray-300);
            color: var(--gray-700);
        }
        
        .btn-outline:hover {
            background-color: var(--gray-100);
        }
        
        /* Cards */
        .card {
            background-color: white;
            border-radius: var(--rounded);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        /* Dashboard grid */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(1, 1fr);
            gap: 1.5rem;
        }
        
        @media (min-width: 768px) {
            .dashboard-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (min-width: 1024px) {
            .dashboard-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }
        
        /* Metrics */
        .metric-card {
            border-radius: var(--rounded);
            padding: 1.5rem;
            color: white;
        }
        
        .metric-card-blue {
            background-color: var(--primary);
        }
        
        .metric-card-green {
            background-color: var(--success);
        }
        
        .metric-card-purple {
            background-color: var(--secondary);
        }
        
        .metric-card-orange {
            background-color: var(--warning);
        }
        
        .metric-title {
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
        }
        
        /* Tables */
        .table-container {
            overflow-x: auto;
        }
        
        .table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .table th {
            background-color: var(--gray-50);
            padding: 0.75rem 1rem;
            text-align: left;
            font-weight: 600;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--gray-500);
        }
        
        .table td {
            padding: 1rem;
            border-bottom: 1px solid var(--gray-200);
            font-size: 0.875rem;
        }
        
        .table tr:last-child td {
            border-bottom: none;
        }
        
        /* Upload area */
        .upload-area {
            border: 2px dashed var(--gray-300);
            border-radius: var(--rounded);
            padding: 3rem;
            text-align: center;
            background-color: white;
            transition: all 0.2s ease;
            margin-bottom: 2rem;
        }
        
        .upload-area.dragging {
            border-color: var(--primary);
            background-color: var(--primary-light);
        }
        
        .upload-icon {
            width: 4rem;
            height: 4rem;
            margin: 0 auto 1rem;
            color: var(--gray-400);
        }
        
        .upload-area.dragging .upload-icon {
            color: var(--primary);
        }
        
        /* Charts */
        .chart-container {
            height: 300px;
            width: 100%;
        }
        
        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Layout utilities */
        .flex {
            display: flex;
        }
        
        .justify-between {
            justify-content: space-between;
        }
        
        .items-center {
            align-items: center;
        }
        
        .gap-4 {
            gap: 1rem;
        }
        
        .mb-4 {
            margin-bottom: 1rem;
        }
        
        .mb-6 {
            margin-bottom: 1.5rem;
        }
        
        .p-4 {
            padding: 1rem;
        }
        
        .text-center {
            text-align: center;
        }
        
        .text-lg {
            font-size: 1.125rem;
        }
        
        .text-xl {
            font-size: 1.25rem;
        }
        
        .text-2xl {
            font-size: 1.5rem;
        }
        
        .text-3xl {
            font-size: 1.875rem;
        }
        
        .font-bold {
            font-weight: 700;
        }
        
        .font-semibold {
            font-weight: 600;
        }
        
        .text-blue-800 {
            color: var(--primary-dark);
        }
        
        .text-gray-600 {
            color: var(--gray-600);
        }
        
        .bg-blue-50 {
            background-color: #eff6ff;
        }
        
        .bg-red-50 {
            background-color: #fef2f2;
        }
        
        .border-red-200 {
            border-color: #fecaca;
        }
        
        .text-red-600 {
            color: var(--danger);
        }
        
        .text-red-800 {
            color: #991b1b;
        }
        
        .min-h-screen {
            min-height: 100vh;
        }
        
        .cursor-pointer {
            cursor: pointer;
        }
        
        .truncate {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;
        const { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } = Recharts;
        const XLSX = window.XLSX;
        const LucideReact = window.lucideReact;
        
        // Create icons from Lucide
        const Upload = LucideReact.Upload;
        const FileSpreadsheet = LucideReact.FileSpreadsheet;
        const AlertCircle = LucideReact.AlertCircle;
        
        const MattressDashboard = () => {
            // File handling state
            const [uploadedFile, setUploadedFile] = useState(null);
            const [fileData, setFileData] = useState(null);
            const [showOnboarding, setShowOnboarding] = useState(true);
            
            // State variables
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            const [allData, setAllData] = useState([]);
            const [filteredData, setFilteredData] = useState([]);
            const [availableDateRange, setAvailableDateRange] = useState({
                startDate: new Date('2024-01-01'),
                endDate: new Date('2025-03-30')
            });
            const [dateRange, setDateRange] = useState({
                startDate: new Date('2024-01-01'),
                endDate: new Date('2025-03-30')
            });
            
            // Analysis state
            const [metrics, setMetrics] = useState({
                revenue: 0,
                units: 0,
                avgPrice: 0,
                attachmentRate: 0
            });
            const [topBrands, setTopBrands] = useState([]);
            const [attachments, setAttachments] = useState([]);
            const [selectedBrand, setSelectedBrand] = useState(null);
            const [selectedCategory, setSelectedCategory] = useState(null);
            
            // Onboarding Component
            const OnboardingScreen = () => {
                const [isDragging, setIsDragging] = useState(false);
                const [uploadError, setUploadError] = useState(null);
                const [isValidating, setIsValidating] = useState(false);
                
                const handleDragOver = (e) => {
                    e.preventDefault();
                    setIsDragging(true);
                };
                
                const handleDragLeave = (e) => {
                    e.preventDefault();
                    setIsDragging(false);
                };
                
                const validateExcelStructure = (data) => {
                    // Check if data exists and has rows
                    if (!data || data.length < 2) {
                        return { valid: false, message: "File appears to be empty or has insufficient data." };
                    }
                    
                    // Check minimum columns (expecting at least 36 columns based on the data structure)
                    const firstRow = data[0];
                    if (!firstRow || firstRow.length < 36) {
                        return { valid: false, message: "File doesn't have the expected number of columns (minimum 36 required)." };
                    }
                    
                    // Validate some expected column positions have data
                    let hasValidData = false;
                    for (let i = 1; i < Math.min(data.length, 10); i++) {
                        const row = data[i];
                        if (row && row.length >= 36 && row[0] !== undefined && row[2] !== undefined) {
                            hasValidData = true;
                            break;
                        }
                    }
                    
                    if (!hasValidData) {
                        return { valid: false, message: "File structure doesn't match expected format." };
                    }
                    
                    return { valid: true, message: "File structure validated successfully." };
                };
                
                const processFile = async (file) => {
                    setIsValidating(true);
                    setUploadError(null);
                    
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const workbook = XLSX.read(arrayBuffer, { cellDates: true });
                        
                        if (!workbook.SheetNames || workbook.SheetNames.length === 0) {
                            throw new Error("No sheets found in the Excel file.");
                        }
                        
                        const sheet = workbook.Sheets[workbook.SheetNames[0]];
                        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                        
                        // Validate structure
                        const validation = validateExcelStructure(jsonData);
                        if (!validation.valid) {
                            throw new Error(validation.message);
                        }
                        
                        // If valid, store the file data
                        setFileData(jsonData);
                        setUploadedFile(file);
                        setShowOnboarding(false);
                        
                    } catch (err) {
                        console.error("Error processing file:", err);
                        setUploadError(err.message || "Failed to process the Excel file. Please ensure it's a valid .xlsx file.");
                    } finally {
                        setIsValidating(false);
                    }
                };
                
                const handleDrop = async (e) => {
                    e.preventDefault();
                    setIsDragging(false);
                    
                    const files = e.dataTransfer.files;
                    if (files && files.length > 0) {
                        const file = files[0];
                        if (file.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' || 
                            file.name.endsWith('.xlsx')) {
                            await processFile(file);
                        } else {
                            setUploadError("Please upload an Excel file (.xlsx)");
                        }
                    }
                };
                
                const handleFileSelect = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        await processFile(file);
                    }
                };
                
                return (
                    <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
                        <div className="max-w-2xl w-full">
                            <div className="text-center mb-8">
                                <h1 className="text-3xl font-bold text-blue-800 mb-4">Mattress Sales Dashboard</h1>
                                <p className="text-gray-600">Upload your sales data Excel file to get started</p>
                            </div>
                            
                            <div
                                className={`upload-area ${isDragging ? 'dragging' : ''}`}
                                onDragOver={handleDragOver}
                                onDragLeave={handleDragLeave}
                                onDrop={handleDrop}
                            >
                                <div className="text-center">
                                    <div className="flex justify-center mb-4">
                                        {isValidating ? (
                                            <div className="spinner"></div>
                                        ) : (
                                            <Upload className={`upload-icon ${isDragging ? 'text-blue-500' : 'text-gray-400'}`} />
                                        )}
                                    </div>
                                    
                                    <h3 className="text-lg font-semibold mb-2">
                                        {isValidating ? 'Validating file...' : 'Drag and drop your Excel file here'}
                                    </h3>
                                    <p className="text-gray-500 mb-4">or</p>
                                    
                                    <label className="inline-block">
                                        <input
                                            type="file"
                                            className="hidden"
                                            accept=".xlsx"
                                            onChange={handleFileSelect}
                                            disabled={isValidating}
                                        />
                                        <span className="btn btn-primary">
                                            Browse Files
                                        </span>
                                    </label>
                                    
                                    <p className="text-sm text-gray-500 mt-4">Supported format: .xlsx</p>
                                </div>
                                
                                {uploadError && (
                                    <div className="mt-4 p-4 bg-red-50 border border-red-200 rounded flex items-start">
                                        <AlertCircle className="h-5 w-5 text-red-600 mr-2 mt-0.5" />
                                        <div>
                                            <p className="text-red-800 font-medium">Upload Error</p>
                                            <p className="text-red-600 text-sm">{uploadError}</p>
                                        </div>
                                    </div>
                                )}
                            </div>
                            
                            <div className="mt-8 bg-blue-50 rounded-lg p-6">
                                <h4 className="font-semibold text-blue-900 mb-3">Expected File Structure</h4>
                                <div className="space-y-2 text-sm text-blue-800">
                                    <p>Your Excel file should contain sales data with the following columns:</p>
                                    <ul className="list-disc list-inside space-y-1 ml-4">
                                        <li>Column A: Quantity</li>
                                        <li>Column B: SKU</li>
                                        <li>Column C: Product Description</li>
                                        <li>Column D: Price</li>
                                        <li>Column P: Vendor</li>
                                        <li>Column Q: Category (MATT for mattresses)</li>
                                        <li>Column X: Order Number</li>
                                        <li>Column Y: Order Date</li>
                                        <li>Column AJ: Location</li>
                                    </ul>
                                    <p className="mt-3 text-xs text-gray-600">
                                        The file should have at least 36 columns with order details and product information.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };
            
            // Process raw Excel data into usable format
            const processData = (jsonData) => {
                const products = [];
                
                // Skip header row, start from index 1
                for (let i = 1; i < jsonData.length; i++) {
                    const row = jsonData[i];
                    if (!row || row.length < 20) continue;
                    
                    // Skip total rows
                    if (row[0] && String(row[0]).startsWith('Total For Order')) continue;
                    
                    // Extract product information using fixed indices
                    const product = {
                        quantity: Number(row[0]) || 0,
                        sku: row[1] || '',
                        description: row[2] || '',
                        price: Number(row[3]) || 0,
                        vendor: row[15] || '',
                        category: String(row[16] || ''),
                        orderNumber: row[23] || '',
                        orderDate: row[24] instanceof Date ? row[24] : new Date(row[24]),
                        location: row[35] || ''
                    };
                    
                    products.push(product);
                }
                
                return products;
            };
            
            // Find min and max dates in the dataset
            const findAvailableDateRange = (products) => {
                if (!products || products.length === 0) {
                    return {
                        startDate: new Date('2024-01-01'),
                        endDate: new Date('2025-03-30')
                    };
                }
                
                // Get all valid dates
                const dates = products
                    .filter(p => p.orderDate && p.orderDate instanceof Date && !isNaN(p.orderDate.getTime()))
                    .map(p => p.orderDate.getTime());
                
                if (dates.length === 0) {
                    return {
                        startDate: new Date('2024-01-01'),
                        endDate: new Date('2025-03-30')
                    };
                }
                
                // Find min and max dates
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                
                return {
                    startDate: minDate,
                    endDate: maxDate
                };
            };
            
            // Filter data by date range
            const filterByDateRange = (products, startDate, endDate) => {
                return products.filter(product => {
                    if (!product.orderDate) return false;
                    const productDate = new Date(product.orderDate);
                    return productDate >= startDate && productDate <= endDate;
                });
            };
            
            // Handle date range changes
            const handleDateChange = (type, newDate) => {
                // Ensure date is within available range
                const availableStart = availableDateRange.startDate;
                const availableEnd = availableDateRange.endDate;
                
                // Clamp to available range
                if (newDate < availableStart) newDate = availableStart;
                if (newDate > availableEnd) newDate = availableEnd;
                
                // Also ensure start date <= end date and vice versa
                let newStartDate = type === 'startDate' ? newDate : dateRange.startDate;
                let newEndDate = type === 'endDate' ? newDate : dateRange.endDate;
                
                // Adjust if needed
                if (newStartDate > newEndDate) {
                    if (type === 'startDate') {
                        newStartDate = newEndDate;
                    } else {
                        newEndDate = newStartDate;
                    }
                }
                
                // Update state
                setDateRange({
                    startDate: newStartDate,
                    endDate: newEndDate
                });
                
                // Apply the new date filter
                const filtered = filterByDateRange(allData, newStartDate, newEndDate);
                setFilteredData(filtered);
                
                // Update all analysis based on filtered data
                analyzeData(filtered);
            };
            
            // Check if a product is an adjustable base
            const isAdjustable = (product) => {
                if (!product.description) return false;
                const desc = product.description.toLowerCase();
                return desc.includes('adjustable') || 
                       desc.includes('motion') || 
                       desc.includes('power base');
            };
            
            // Calculate attachment rate
            const calculateAttachmentRate = (products) => {
                // Group by order
                const orders = {};
                
                products.forEach(product => {
                    if (!product.orderNumber) return;
                    
                    if (!orders[product.orderNumber]) {
                        orders[product.orderNumber] = {
                            hasMattress: false,
                            hasAttachment: false
                        };
                    }
                    
                    // Check if order has mattress
                    if (product.category === 'MATT' && !isAdjustable(product)) {
                        orders[product.orderNumber].hasMattress = true;
                    }
                    // Check if order has potential attachment
                    else if (product.category && product.category !== 'MATT') {
                        orders[product.orderNumber].hasAttachment = true;
                    }
                });
                
                // Count orders with mattresses and attachments
                let mattressOrderCount = 0;
                let attachmentOrderCount = 0;
                
                Object.values(orders).forEach(order => {
                    if (order.hasMattress) {
                        mattressOrderCount++;
                        if (order.hasAttachment) {
                            attachmentOrderCount++;
                        }
                    }
                });
                
                return mattressOrderCount > 0 ? (attachmentOrderCount / mattressOrderCount * 100) : 0;
            };
            
            // Analyze the data and update all metrics and charts
            const analyzeData = (products) => {
                try {
                    // Get mattress products (category MATT)
                    const mattresses = products.filter(p => p.category === 'MATT' && !isAdjustable(p));
                    
                    // Calculate basic metrics
                    const revenue = mattresses.reduce((sum, p) => sum + p.price, 0);
                    const units = mattresses.reduce((sum, p) => sum + p.quantity, 0);
                    const avgPrice = units > 0 ? revenue / units : 0;
                    
                    // Calculate attachment rate
                    const attachmentRate = calculateAttachmentRate(products);
                    
                    setMetrics({
                        revenue,
                        units,
                        avgPrice,
                        attachmentRate
                    });
                    
                    // Define the getBrand function inside analyzeData to ensure it's always available
                    const getBrand = (product) => {
                        if (!product || !product.description && !product.vendor) return 'Other';
                        
                        const desc = (product.description || '').toLowerCase();
                        const vendor = (product.vendor || '').toLowerCase();
                        
                        if (desc.includes('sealy') || vendor.includes('sealy')) return 'Sealy';
                        if (desc.includes('stearns') || desc.includes('foster')) return 'Stearns & Foster';
                        if (desc.includes('tempur') || vendor.includes('temp')) return 'Tempur-Pedic';
                        if (desc.includes('purple') || vendor.includes('purpl')) return 'Purple';
                        if (desc.includes('mlily') || vendor.includes('mlily')) return 'MLily';
                        if (desc.includes('ashley') || vendor.includes('ashle')) return 'Ashley';
                        
                        return 'Other';
                    };
                    
                    // Group by brand
                    const brandGroups = {};
                    
                    mattresses.forEach(product => {
                        const brand = getBrand(product);
                        
                        if (!brandGroups[brand]) {
                            brandGroups[brand] = {
                                brand,
                                products: [],
                                revenue: 0,
                                units: 0
                            };
                        }
                        
                        brandGroups[brand].products.push(product);
                        brandGroups[brand].revenue += product.price;
                        brandGroups[brand].units += product.quantity;
                    });
                    
                    // Process each brand to get top models
                    Object.values(brandGroups).forEach(group => {
                        // Group by model (description)
                        const modelGroups = {};
                        
                        group.products.forEach(product => {
                            if (!product.description) return;
                            
                            if (!modelGroups[product.description]) {
                                modelGroups[product.description] = {
                                    description: product.description,
                                    sku: product.sku,
                                    revenue: 0,
                                    units: 0
                                };
                            }
                            
                            modelGroups[product.description].revenue += product.price;
                            modelGroups[product.description].units += product.quantity;
                        });
                        
                        // Get top models by revenue
                        group.topModels = Object.values(modelGroups)
                            .sort((a, b) => b.revenue - a.revenue)
                            .slice(0, 5)
                            .map(model => ({
                                ...model,
                                avgPrice: model.units > 0 ? model.revenue / model.units : 0
                            }));
                    });
                    
                    // Sort brands by revenue and set state
                    setTopBrands(
                        Object.values(brandGroups)
                            .sort((a, b) => b.revenue - a.revenue)
                    );
                    
                    // Generate attachment data
                    analyzeAttachments(products);
                } catch (err) {
                    console.error("Error analyzing data:", err);
                    setError("Error analyzing data: " + err.message);
                }
            };
            
            // Analyze attachment products
            const analyzeAttachments = (products) => {
                // Find mattress orders
                const mattressOrders = new Set();
                
                products.forEach(product => {
                    if (product.category === 'MATT' && !isAdjustable(product) && product.orderNumber) {
                        mattressOrders.add(product.orderNumber);
                    }
                });
                
                // Analyze attachments
                const categories = {};
                
                products.forEach(product => {
                    // Skip if not an attachment in a mattress order
                    if (!product.orderNumber || !mattressOrders.has(product.orderNumber)) return;
                    if (!product.category || product.category === 'MATT') return;
                    
                    // Add category if not exists
                    if (!categories[product.category]) {
                        categories[product.category] = {
                            name: product.category,
                            count: 0,
                            revenue: 0,
                            products: []
                        };
                    }
                    
                    // Add to category data
                    categories[product.category].count++;
                    categories[product.category].revenue += product.price;
                    categories[product.category].products.push(product);
                });
                
                // Calculate attachment rates
                const categoryData = Object.values(categories).map(cat => ({
                    ...cat,
                    rate: (cat.count / mattressOrders.size * 100).toFixed(1)
                }));
                
                // Sort by revenue
                const sortedCategories = categoryData
                    .sort((a, b) => b.revenue - a.revenue)
                    .slice(0, 6);
                
                // Process products within each category
                sortedCategories.forEach(category => {
                    // Group by product description
                    const productGroups = {};
                    
                    category.products.forEach(product => {
                        if (!product.description) return;
                        
                        if (!productGroups[product.description]) {
                            productGroups[product.description] = {
                                description: product.description,
                                sku: product.sku,
                                count: 0,
                                revenue: 0,
                                orders: new Set()
                            };
                        }
                        
                        productGroups[product.description].count += product.quantity;
                        productGroups[product.description].revenue += product.price;
                        productGroups[product.description].orders.add(product.orderNumber);
                    });
                    
                    // Calculate stats and convert orders sets
                    Object.values(productGroups).forEach(product => {
                        product.avgPrice = product.count > 0 ? product.revenue / product.count : 0;
                        product.attachmentRate = (product.orders.size / mattressOrders.size * 100).toFixed(1);
                        product.orderCount = product.orders.size;
                        delete product.orders;
                    });
                    
                    // Get top products
                    category.topProducts = Object.values(productGroups)
                        .sort((a, b) => b.revenue - a.revenue)
                        .slice(0, 5);
                });
                
                setAttachments(sortedCategories);
            };
            
            // Format currency
            const formatCurrency = (value) => {
                return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD'
                }).format(value);
            };
            
            // Date filter component
            const DateFilter = () => {
                const formatDateForInput = (date) => {
                    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
                        return '';
                    }
                    return date.toISOString().split('T')[0];
                };
                
                return (
                    <div className="flex flex-wrap items-center gap-4">
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-1">Start Date</label>
                            <input
                                type="date"
                                className="p-2 border border-gray-300 rounded"
                                value={formatDateForInput(dateRange.startDate)}
                                min={formatDateForInput(availableDateRange.startDate)}
                                max={formatDateForInput(availableDateRange.endDate)}
                                onChange={(e) => handleDateChange('startDate', new Date(e.target.value))}
                            />
                        </div>
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-1">End Date</label>
                            <input
                                type="date"
                                className="p-2 border border-gray-300 rounded"
                                value={formatDateForInput(dateRange.endDate)}
                                min={formatDateForInput(availableDateRange.startDate)}
                                max={formatDateForInput(availableDateRange.endDate)}
                                onChange={(e) => handleDateChange('endDate', new Date(e.target.value))}
                            />
                        </div>
                        <div className="ml-4 text-sm text-gray-500">
                            <p>Available data: {availableDateRange.startDate instanceof Date ? availableDateRange.startDate.toLocaleDateString() : 'N/A'} to {availableDateRange.endDate instanceof Date ? availableDateRange.endDate.toLocaleDateString() : 'N/A'}</p>
                        </div>
                    </div>
                );
            };
            
            // Top Brands component
            const TopBrandsSection = () => {
                if (selectedBrand) {
                    const brand = topBrands.find(b => b.brand === selectedBrand);
                    
                    return (
                        <div>
                            <div className="mb-4">
                                <button 
                                    onClick={() => setSelectedBrand(null)} 
                                    className="text-blue-600 hover:underline flex items-center mb-2"
                                >
                                    ← Back to all brands
                                </button>
                                <h3 className="font-semibold text-lg">{selectedBrand}</h3>
                            </div>
                            
                            <div className="table-container">
                                <table className="table">
                                    <thead>
                                        <tr>
                                            <th>Mattress</th>
                                            <th>SKU</th>
                                            <th>Units Sold</th>
                                            <th>Revenue</th>
                                            <th>Avg Price</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {brand.topModels.map((model, idx) => (
                                            <tr key={idx}>
                                                <td className="font-medium text-gray-900">
                                                    {model.description}
                                                </td>
                                                <td className="text-gray-500">
                                                    {model.sku || 'N/A'}
                                                </td>
                                                <td className="text-gray-500">
                                                    {model.units}
                                                </td>
                                                <td className="text-gray-500">
                                                    {formatCurrency(model.revenue)}
                                                </td>
                                                <td className="text-gray-500">
                                                    {formatCurrency(model.avgPrice)}
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    );
                }
                
                return (
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                        {topBrands.map((brand) => (
                            <div 
                                key={brand.brand} 
                                className="border rounded p-3 cursor-pointer hover:bg-blue-50"
                                onClick={() => setSelectedBrand(brand.brand)}
                            >
                                <h3 className="font-semibold text-md mb-2">{brand.brand}</h3>
                                <div className="text-sm">
                                    <div className="font-medium mb-1">Top Models</div>
                                    {brand.topModels.slice(0, 2).map((model, idx) => (
                                        <div key={idx} className="flex flex-col mb-2">
                                            <div className="truncate max-w-full font-medium" title={model.description}>
                                                {model.description}
                                            </div>
                                            <div className="flex justify-between">
                                                <span className="text-xs text-gray-500">Units: {model.units}</span>
                                                <span>{formatCurrency(model.revenue)}</span>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>
                );
            };
            
            // Attachments Section
            const AttachmentsSection = () => {
                if (selectedCategory) {
                    const category = attachments.find(c => c.name === selectedCategory);
                    
                    return (
                        <div>
                            <div className="mb-4">
                                <button 
                                    onClick={() => setSelectedCategory(null)} 
                                    className="text-blue-600 hover:underline flex items-center mb-2"
                                >
                                    ← Back to all categories
                                </button>
                                <h3 className="font-semibold text-lg">
                                    {selectedCategory} Products with Mattress Purchases
                                </h3>
                            </div>
                            
                            <div className="table-container">
                                <table className="table">
                                    <thead>
                                        <tr>
                                            <th>Product</th>
                                            <th>SKU</th>
                                            <th>Units Sold</th>
                                            <th>Revenue</th>
                                            <th>Avg Price</th>
                                            <th>Attachment Rate</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {category.topProducts.map((product, idx) => (
                                            <tr key={idx}>
                                                <td className="font-medium text-gray-900">
                                                    {product.description}
                                                </td>
                                                <td className="text-gray-500">
                                                    {product.sku || 'N/A'}
                                                </td>
                                                <td className="text-gray-500">
                                                    {product.count}
                                                </td>
                                                <td className="text-gray-500">
                                                    {formatCurrency(product.revenue)}
                                                </td>
                                                <td className="text-gray-500">
                                                    {formatCurrency(product.avgPrice)}
                                                </td>
                                                <td className="text-gray-500">
                                                    {product.attachmentRate}%
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    );
                }
                
                return (
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                        {attachments.map((category) => (
                            <div 
                                key={category.name} 
                                className="border rounded p-3 cursor-pointer hover:bg-blue-50"
                                onClick={() => setSelectedCategory(category.name)}
                            >
                                <h3 className="font-semibold text-md mb-2">{category.name}</h3>
                                <div className="text-sm">
                                    <div className="font-medium mb-1">Top Products</div>
                                    {category.topProducts.slice(0, 2).map((product, idx) => (
                                        <div key={idx} className="flex flex-col mb-2">
                                            <div className="truncate max-w-full font-medium" title={product.description}>
                                                {product.description}
                                            </div>
                                            <div className="flex justify-between">
                                                <span className="text-xs text-gray-500">{product.attachmentRate}% with Mattress</span>
                                                <span>{formatCurrency(product.revenue)}</span>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>
                );
            };
            
            // Header with file info and change file button
            const DashboardHeader = () => {
                return (
                    <div className="flex justify-between items-center mb-6">
                        <h1 className="text-3xl font-bold text-blue-800">Mattress Sales Dashboard</h1>
                        <div className="flex items-center gap-4">
                            <div className="text-sm text-gray-600">
                                <FileSpreadsheet className="inline h-4 w-4 mr-1" />
                                {uploadedFile?.name || 'No file loaded'}
                            </div>
                            <button
                                onClick={() => {
                                    setShowOnboarding(true);
                                    setUploadedFile(null);
                                    setFileData(null);
                                    setAllData([]);
                                    setFilteredData([]);
                                }}
                                className="btn btn-outline"
                            >
                                Change File
                            </button>
                        </div>
                    </div>
                );
            };
            
            // Load data when file data is available
            useEffect(() => {
                const loadData = async () => {
                    if (!fileData) return;
                    
                    try {
                        setIsLoading(true);
                        setError(null);
                        
                        // Basic processing
                        const products = processData(fileData);
                        setAllData(products);
                        
                        // Determine available date range from the data
                        const dataDateRange = findAvailableDateRange(products);
                        setAvailableDateRange(dataDateRange);
                        
                        // Set initial date range to the available range
                        setDateRange({
                            startDate: dataDateRange.startDate,
                            endDate: dataDateRange.endDate
                        });
                        
                        // Apply initial date filter
                        const filtered = filterByDateRange(products, dataDateRange.startDate, dataDateRange.endDate);
                        setFilteredData(filtered);
                        
                        // Generate metrics and analysis
                        analyzeData(filtered);
                        
                        setIsLoading(false);
                    } catch (err) {
                        console.error("Error loading data:", err);
                        setError("Failed to process data: " + err.message);
                        setIsLoading(false);
                    }
                };
                
                loadData();
            }, [fileData]);
            
            // Show onboarding if no file is loaded
            if (showOnboarding) {
                return <OnboardingScreen />;
            }
            
            return (
                <div className="bg-gray-50 min-h-screen p-4">
                    {isLoading ? (
                        <div className="flex items-center justify-center h-64">
                            <p className="text-xl font-semibold text-blue-600">Processing sales data...</p>
                        </div>
                    ) : error ? (
                        <div className="max-w-6xl mx-auto">
                            <DashboardHeader />
                            <div className="bg-red-100 border border-red-400 text-red-700 p-4 rounded">
                                <p className="font-bold">Error processing data</p>
                                <p>{error}</p>
                            </div>
                        </div>
                    ) : (
                        <div className="max-w-6xl mx-auto">
                            <DashboardHeader />
                            
                            {/* Filters */}
                            <div className="card mb-6">
                                <h2 className="text-xl font-semibold mb-4">Date Range Filter</h2>
                                <DateFilter />
                            </div>
                            
                            {/* Summary Metrics */}
                            <div className="card mb-6">
                                <h2 className="text-xl font-semibold mb-4">Dashboard Summary</h2>
                                <div className="dashboard-grid">
                                    <div className="metric-card metric-card-blue">
                                        <h3 className="metric-title">Total Mattress Revenue</h3>
                                        <p className="metric-value">{formatCurrency(metrics.revenue)}</p>
                                    </div>
                                    <div className="metric-card metric-card-green">
                                        <h3 className="metric-title">Mattress Units Sold</h3>
                                        <p className="metric-value">{metrics.units}</p>
                                    </div>
                                    <div className="metric-card metric-card-purple">
                                        <h3 className="metric-title">Average Mattress Price</h3>
                                        <p className="metric-value">{formatCurrency(metrics.avgPrice)}</p>
                                    </div>
                                    <div className="metric-card metric-card-orange">
                                        <h3 className="metric-title">Attachment Rate</h3>
                                        <p className="metric-value">{metrics.attachmentRate.toFixed(1)}%</p>
                                    </div>
                                </div>
                            </div>
                            
                            {/* Top Mattresses */}
                            <div className="card mb-6">
                                <h2 className="text-xl font-semibold mb-4">Top Mattresses by Brand</h2>
                                {topBrands.length === 0 ? (
                                    <p className="text-gray-500">No mattress data available for the selected date range.</p>
                                ) : (
                                    <TopBrandsSection />
                                )}
                            </div>
                            
                            {/* Attachment Rate Analysis */}
                            <div className="card mb-6">
                                <h2 className="text-xl font-semibold mb-4">Attachment Rate Analysis</h2>
                                {attachments.length === 0 ? (
                                    <p className="text-gray-500">No attachment data available for the selected date range.</p>
                                ) : (
                                    <div className="chart-container">
                                        <ResponsiveContainer width="100%" height="100%">
                                            <BarChart data={attachments}>
                                                <CartesianGrid strokeDasharray="3 3" />
                                                <XAxis dataKey="name" />
                                                <YAxis yAxisId="left" orientation="left" stroke="#8884d8" />
                                                <YAxis yAxisId="right" orientation="right" stroke="#82ca9d" />
                                                <Tooltip 
                                                    formatter={(value, name) => {
                                                        if (name === 'rate') return `${value}%`;
                                                        return name === 'revenue' ? formatCurrency(value) : value;
                                                    }}
                                                />
                                                <Legend />
                                                <Bar yAxisId="left" dataKey="rate" name="Attachment Rate %" fill="#8884d8" />
                                                <Bar yAxisId="right" dataKey="revenue" name="Revenue" fill="#82ca9d" />
                                            </BarChart>
                                        </ResponsiveContainer>
                                    </div>
                                )}
                            </div>
                            
                            {/* Top Attachment Products */}
                            <div className="card mb-6">
                                <h2 className="text-xl font-semibold mb-4">Top Attachment Products By Category</h2>
                                {attachments.length === 0 ? (
                                    <p className="text-gray-500">No attachment product data available for the selected date range.</p>
                                ) : (
                                    <AttachmentsSection />
                                )}
                            </div>
                            
                            <div className="text-center text-gray-500 text-sm mt-8">
                                <p>Date range: {dateRange.startDate instanceof Date ? dateRange.startDate.toLocaleDateString() : 'N/A'} to {dateRange.endDate instanceof Date ? dateRange.endDate.toLocaleDateString() : 'N/A'}</p>
                                <p className="mt-1">Available date range: {availableDateRange.startDate instanceof Date ? availableDateRange.startDate.toLocaleDateString() : 'N/A'} to {availableDateRange.endDate instanceof Date ? availableDateRange.endDate.toLocaleDateString() : 'N/A'}</p>
                                <p className="mt-1">Total products: {allData.length} | Filtered products: {filteredData.length}</p>
                            </div>
                        </div>
                    )}
                </div>
            );
        };
        
        const App = () => {
            return <MattressDashboard />;
        };
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
