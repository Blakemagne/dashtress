import React, { useState, useEffect } from 'react';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import * as XLSX from 'xlsx';
import { Upload, FileSpreadsheet, AlertCircle } from 'lucide-react';

const MattressDashboard = () => {
  // File handling state
  const [uploadedFile, setUploadedFile] = useState(null);
  const [fileData, setFileData] = useState(null);
  const [showOnboarding, setShowOnboarding] = useState(true);
  
  // State variables
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [allData, setAllData] = useState([]);
  const [filteredData, setFilteredData] = useState([]);
  const [availableDateRange, setAvailableDateRange] = useState({
    startDate: new Date('2024-01-01'),
    endDate: new Date('2025-03-30')
  });
  const [dateRange, setDateRange] = useState({
    startDate: new Date('2024-01-01'),
    endDate: new Date('2025-03-30')
  });
  
  // Analysis state
  const [metrics, setMetrics] = useState({
    revenue: 0,
    units: 0,
    avgPrice: 0,
    attachmentRate: 0
  });
  const [topBrands, setTopBrands] = useState([]);
  const [attachments, setAttachments] = useState([]);
  const [selectedBrand, setSelectedBrand] = useState(null);
  const [selectedCategory, setSelectedCategory] = useState(null);
  
  // Onboarding Component
  const OnboardingScreen = () => {
    const [isDragging, setIsDragging] = useState(false);
    const [uploadError, setUploadError] = useState(null);
    const [isValidating, setIsValidating] = useState(false);
    
    const handleDragOver = (e) => {
      e.preventDefault();
      setIsDragging(true);
    };
    
    const handleDragLeave = (e) => {
      e.preventDefault();
      setIsDragging(false);
    };
    
    const validateExcelStructure = (data) => {
      // Check if data exists and has rows
      if (!data || data.length < 2) {
        return { valid: false, message: "File appears to be empty or has insufficient data." };
      }
      
      // Check minimum columns (expecting at least 36 columns based on the data structure)
      const firstRow = data[0];
      if (!firstRow || firstRow.length < 36) {
        return { valid: false, message: "File doesn't have the expected number of columns (minimum 36 required)." };
      }
      
      // Validate some expected column positions have data
      let hasValidData = false;
      for (let i = 1; i < Math.min(data.length, 10); i++) {
        const row = data[i];
        if (row && row.length >= 36 && row[0] !== undefined && row[2] !== undefined) {
          hasValidData = true;
          break;
        }
      }
      
      if (!hasValidData) {
        return { valid: false, message: "File structure doesn't match expected format." };
      }
      
      return { valid: true, message: "File structure validated successfully." };
    };
    
    const processFile = async (file) => {
      setIsValidating(true);
      setUploadError(null);
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        const workbook = XLSX.read(arrayBuffer, { cellDates: true });
        
        if (!workbook.SheetNames || workbook.SheetNames.length === 0) {
          throw new Error("No sheets found in the Excel file.");
        }
        
        const sheet = workbook.Sheets[workbook.SheetNames[0]];
        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        
        // Validate structure
        const validation = validateExcelStructure(jsonData);
        if (!validation.valid) {
          throw new Error(validation.message);
        }
        
        // If valid, store the file data
        setFileData(jsonData);
        setUploadedFile(file);
        setShowOnboarding(false);
        
      } catch (err) {
        console.error("Error processing file:", err);
        setUploadError(err.message || "Failed to process the Excel file. Please ensure it's a valid .xlsx file.");
      } finally {
        setIsValidating(false);
      }
    };
    
    const handleDrop = async (e) => {
      e.preventDefault();
      setIsDragging(false);
      
      const files = e.dataTransfer.files;
      if (files && files.length > 0) {
        const file = files[0];
        if (file.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' || 
            file.name.endsWith('.xlsx')) {
          await processFile(file);
        } else {
          setUploadError("Please upload an Excel file (.xlsx)");
        }
      }
    };
    
    const handleFileSelect = async (e) => {
      const file = e.target.files[0];
      if (file) {
        await processFile(file);
      }
    };
    
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
        <div className="max-w-2xl w-full">
          <div className="text-center mb-8">
            <h1 className="text-3xl font-bold text-blue-800 mb-4">Mattress Sales Dashboard</h1>
            <p className="text-gray-600">Upload your sales data Excel file to get started</p>
          </div>
          
          <div
            className={`bg-white rounded-lg shadow-lg p-8 border-2 border-dashed transition-colors ${
              isDragging ? 'border-blue-500 bg-blue-50' : 'border-gray-300'
            }`}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
          >
            <div className="text-center">
              <div className="flex justify-center mb-4">
                {isValidating ? (
                  <div className="animate-spin rounded-full h-16 w-16 border-b-2 border-blue-600"></div>
                ) : (
                  <Upload className={`h-16 w-16 ${isDragging ? 'text-blue-500' : 'text-gray-400'}`} />
                )}
              </div>
              
              <h3 className="text-lg font-semibold mb-2">
                {isValidating ? 'Validating file...' : 'Drag and drop your Excel file here'}
              </h3>
              <p className="text-gray-500 mb-4">or</p>
              
              <label className="inline-block">
                <input
                  type="file"
                  className="hidden"
                  accept=".xlsx"
                  onChange={handleFileSelect}
                  disabled={isValidating}
                />
                <span className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 cursor-pointer">
                  Browse Files
                </span>
              </label>
              
              <p className="text-sm text-gray-500 mt-4">Supported format: .xlsx</p>
            </div>
            
            {uploadError && (
              <div className="mt-4 p-4 bg-red-50 border border-red-200 rounded flex items-start">
                <AlertCircle className="h-5 w-5 text-red-600 mr-2 mt-0.5" />
                <div>
                  <p className="text-red-800 font-medium">Upload Error</p>
                  <p className="text-red-600 text-sm">{uploadError}</p>
                </div>
              </div>
            )}
          </div>
          
          <div className="mt-8 bg-blue-50 rounded-lg p-6">
            <h4 className="font-semibold text-blue-900 mb-3">Expected File Structure</h4>
            <div className="space-y-2 text-sm text-blue-800">
              <p>Your Excel file should contain sales data with the following columns:</p>
              <ul className="list-disc list-inside space-y-1 ml-4">
                <li>Column A: Quantity</li>
                <li>Column B: SKU</li>
                <li>Column C: Product Description</li>
                <li>Column D: Price</li>
                <li>Column P: Vendor</li>
                <li>Column Q: Category (MATT for mattresses)</li>
                <li>Column X: Order Number</li>
                <li>Column Y: Order Date</li>
                <li>Column AJ: Location</li>
              </ul>
              <p className="mt-3 text-xs text-gray-600">
                The file should have at least 36 columns with order details and product information.
              </p>
            </div>
          </div>
        </div>
      </div>
    );
  };
  
  // Process raw Excel data into usable format
  const processData = (jsonData) => {
    const products = [];
    
    // Skip header row, start from index 1
    for (let i = 1; i < jsonData.length; i++) {
      const row = jsonData[i];
      if (!row || row.length < 20) continue;
      
      // Skip total rows
      if (row[0] && String(row[0]).startsWith('Total For Order')) continue;
      
      // Extract product information using fixed indices
      const product = {
        quantity: Number(row[0]) || 0,
        sku: row[1] || '',
        description: row[2] || '',
        price: Number(row[3]) || 0,
        vendor: row[15] || '',
        category: String(row[16] || ''),
        orderNumber: row[23] || '',
        orderDate: row[24] instanceof Date ? row[24] : new Date(row[24]),
        location: row[35] || ''
      };
      
      products.push(product);
    }
    
    return products;
  };
  
  // Find min and max dates in the dataset
  const findAvailableDateRange = (products) => {
    if (!products || products.length === 0) {
      return {
        startDate: new Date('2024-01-01'),
        endDate: new Date('2025-03-30')
      };
    }
    
    // Get all valid dates
    const dates = products
      .filter(p => p.orderDate && p.orderDate instanceof Date && !isNaN(p.orderDate.getTime()))
      .map(p => p.orderDate.getTime());
    
    if (dates.length === 0) {
      return {
        startDate: new Date('2024-01-01'),
        endDate: new Date('2025-03-30')
      };
    }
    
    // Find min and max dates
    const minDate = new Date(Math.min(...dates));
    const maxDate = new Date(Math.max(...dates));
    
    return {
      startDate: minDate,
      endDate: maxDate
    };
  };
  
  // Filter data by date range
  const filterByDateRange = (products, startDate, endDate) => {
    return products.filter(product => {
      if (!product.orderDate) return false;
      const productDate = new Date(product.orderDate);
      return productDate >= startDate && productDate <= endDate;
    });
  };
  
  // Handle date range changes
  const handleDateChange = (type, newDate) => {
    // Ensure date is within available range
    const availableStart = availableDateRange.startDate;
    const availableEnd = availableDateRange.endDate;
    
    // Clamp to available range
    if (newDate < availableStart) newDate = availableStart;
    if (newDate > availableEnd) newDate = availableEnd;
    
    // Also ensure start date <= end date and vice versa
    let newStartDate = type === 'startDate' ? newDate : dateRange.startDate;
    let newEndDate = type === 'endDate' ? newDate : dateRange.endDate;
    
    // Adjust if needed
    if (newStartDate > newEndDate) {
      if (type === 'startDate') {
        newStartDate = newEndDate;
      } else {
        newEndDate = newStartDate;
      }
    }
    
    // Update state
    setDateRange({
      startDate: newStartDate,
      endDate: newEndDate
    });
    
    // Apply the new date filter
    const filtered = filterByDateRange(allData, newStartDate, newEndDate);
    setFilteredData(filtered);
    
    // Update all analysis based on filtered data
    analyzeData(filtered);
  };
  
  // Check if a product is an adjustable base
  const isAdjustable = (product) => {
    if (!product.description) return false;
    const desc = product.description.toLowerCase();
    return desc.includes('adjustable') || 
           desc.includes('motion') || 
           desc.includes('power base');
  };
  
  // Calculate attachment rate
  const calculateAttachmentRate = (products) => {
    // Group by order
    const orders = {};
    
    products.forEach(product => {
      if (!product.orderNumber) return;
      
      if (!orders[product.orderNumber]) {
        orders[product.orderNumber] = {
          hasMattress: false,
          hasAttachment: false
        };
      }
      
      // Check if order has mattress
      if (product.category === 'MATT' && !isAdjustable(product)) {
        orders[product.orderNumber].hasMattress = true;
      }
      // Check if order has potential attachment
      else if (product.category && product.category !== 'MATT') {
        orders[product.orderNumber].hasAttachment = true;
      }
    });
    
    // Count orders with mattresses and attachments
    let mattressOrderCount = 0;
    let attachmentOrderCount = 0;
    
    Object.values(orders).forEach(order => {
      if (order.hasMattress) {
        mattressOrderCount++;
        if (order.hasAttachment) {
          attachmentOrderCount++;
        }
      }
    });
    
    return mattressOrderCount > 0 ? (attachmentOrderCount / mattressOrderCount * 100) : 0;
  };
  
  // Analyze the data and update all metrics and charts
  const analyzeData = (products) => {
    try {
      // Get mattress products (category MATT)
      const mattresses = products.filter(p => p.category === 'MATT' && !isAdjustable(p));
      
      // Calculate basic metrics
      const revenue = mattresses.reduce((sum, p) => sum + p.price, 0);
      const units = mattresses.reduce((sum, p) => sum + p.quantity, 0);
      const avgPrice = units > 0 ? revenue / units : 0;
      
      // Calculate attachment rate
      const attachmentRate = calculateAttachmentRate(products);
      
      setMetrics({
        revenue,
        units,
        avgPrice,
        attachmentRate
      });
      
      // Define the getBrand function inside analyzeData to ensure it's always available
      const getBrand = (product) => {
        if (!product || !product.description && !product.vendor) return 'Other';
        
        const desc = (product.description || '').toLowerCase();
        const vendor = (product.vendor || '').toLowerCase();
        
        if (desc.includes('sealy') || vendor.includes('sealy')) return 'Sealy';
        if (desc.includes('stearns') || desc.includes('foster')) return 'Stearns & Foster';
        if (desc.includes('tempur') || vendor.includes('temp')) return 'Tempur-Pedic';
        if (desc.includes('purple') || vendor.includes('purpl')) return 'Purple';
        if (desc.includes('mlily') || vendor.includes('mlily')) return 'MLily';
        if (desc.includes('ashley') || vendor.includes('ashle')) return 'Ashley';
        
        return 'Other';
      };
      
      // Group by brand
      const brandGroups = {};
      
      mattresses.forEach(product => {
        const brand = getBrand(product);
        
        if (!brandGroups[brand]) {
          brandGroups[brand] = {
            brand,
            products: [],
            revenue: 0,
            units: 0
          };
        }
        
        brandGroups[brand].products.push(product);
        brandGroups[brand].revenue += product.price;
        brandGroups[brand].units += product.quantity;
      });
      
      // Process each brand to get top models
      Object.values(brandGroups).forEach(group => {
        // Group by model (description)
        const modelGroups = {};
        
        group.products.forEach(product => {
          if (!product.description) return;
          
          if (!modelGroups[product.description]) {
            modelGroups[product.description] = {
              description: product.description,
              sku: product.sku,
              revenue: 0,
              units: 0
            };
          }
          
          modelGroups[product.description].revenue += product.price;
          modelGroups[product.description].units += product.quantity;
        });
        
        // Get top models by revenue
        group.topModels = Object.values(modelGroups)
          .sort((a, b) => b.revenue - a.revenue)
          .slice(0, 5)
          .map(model => ({
            ...model,
            avgPrice: model.units > 0 ? model.revenue / model.units : 0
          }));
      });
      
      // Sort brands by revenue and set state
      setTopBrands(
        Object.values(brandGroups)
          .sort((a, b) => b.revenue - a.revenue)
      );
      
      // Generate attachment data
      analyzeAttachments(products);
    } catch (err) {
      console.error("Error analyzing data:", err);
      setError("Error analyzing data: " + err.message);
    }
  };
  
  // Analyze attachment products
  const analyzeAttachments = (products) => {
    // Find mattress orders
    const mattressOrders = new Set();
    
    products.forEach(product => {
      if (product.category === 'MATT' && !isAdjustable(product) && product.orderNumber) {
        mattressOrders.add(product.orderNumber);
      }
    });
    
    // Analyze attachments
    const categories = {};
    
    products.forEach(product => {
      // Skip if not an attachment in a mattress order
      if (!product.orderNumber || !mattressOrders.has(product.orderNumber)) return;
      if (!product.category || product.category === 'MATT') return;
      
      // Add category if not exists
      if (!categories[product.category]) {
        categories[product.category] = {
          name: product.category,
          count: 0,
          revenue: 0,
          products: []
        };
      }
      
      // Add to category data
      categories[product.category].count++;
      categories[product.category].revenue += product.price;
      categories[product.category].products.push(product);
    });
    
    // Calculate attachment rates
    const categoryData = Object.values(categories).map(cat => ({
      ...cat,
      rate: (cat.count / mattressOrders.size * 100).toFixed(1)
    }));
    
    // Sort by revenue
    const sortedCategories = categoryData
      .sort((a, b) => b.revenue - a.revenue)
      .slice(0, 6);
    
    // Process products within each category
    sortedCategories.forEach(category => {
      // Group by product description
      const productGroups = {};
      
      category.products.forEach(product => {
        if (!product.description) return;
        
        if (!productGroups[product.description]) {
          productGroups[product.description] = {
            description: product.description,
            sku: product.sku,
            count: 0,
            revenue: 0,
            orders: new Set()
          };
        }
        
        productGroups[product.description].count += product.quantity;
        productGroups[product.description].revenue += product.price;
        productGroups[product.description].orders.add(product.orderNumber);
      });
      
      // Calculate stats and convert orders sets
      Object.values(productGroups).forEach(product => {
        product.avgPrice = product.count > 0 ? product.revenue / product.count : 0;
        product.attachmentRate = (product.orders.size / mattressOrders.size * 100).toFixed(1);
        product.orderCount = product.orders.size;
        delete product.orders;
      });
      
      // Get top products
      category.topProducts = Object.values(productGroups)
        .sort((a, b) => b.revenue - a.revenue)
        .slice(0, 5);
    });
    
    setAttachments(sortedCategories);
  };
  
  // Format currency
  const formatCurrency = (value) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(value);
  };
  
  // Date filter component
  const DateFilter = () => {
    const formatDateForInput = (date) => {
      if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
        return '';
      }
      return date.toISOString().split('T')[0];
    };
    
    return (
      <div className="flex flex-wrap items-center gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">Start Date</label>
          <input
            type="date"
            className="p-2 border border-gray-300 rounded"
            value={formatDateForInput(dateRange.startDate)}
            min={formatDateForInput(availableDateRange.startDate)}
            max={formatDateForInput(availableDateRange.endDate)}
            onChange={(e) => handleDateChange('startDate', new Date(e.target.value))}
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">End Date</label>
          <input
            type="date"
            className="p-2 border border-gray-300 rounded"
            value={formatDateForInput(dateRange.endDate)}
            min={formatDateForInput(availableDateRange.startDate)}
            max={formatDateForInput(availableDateRange.endDate)}
            onChange={(e) => handleDateChange('endDate', new Date(e.target.value))}
          />
        </div>
        <div className="ml-4 text-sm text-gray-500">
          <p>Available data: {availableDateRange.startDate instanceof Date ? availableDateRange.startDate.toLocaleDateString() : 'N/A'} to {availableDateRange.endDate instanceof Date ? availableDateRange.endDate.toLocaleDateString() : 'N/A'}</p>
        </div>
      </div>
    );
  };
  
  // Top Brands component
  const TopBrandsSection = () => {
    if (selectedBrand) {
      const brand = topBrands.find(b => b.brand === selectedBrand);
      
      return (
        <div>
          <div className="mb-4">
            <button 
              onClick={() => setSelectedBrand(null)} 
              className="text-blue-600 hover:underline flex items-center mb-2"
            >
              ← Back to all brands
            </button>
            <h3 className="font-semibold text-lg">{selectedBrand}</h3>
          </div>
          
          <div className="overflow-auto">
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Mattress
                  </th>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    SKU
                  </th>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Units Sold
                  </th>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Revenue
                  </th>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Avg Price
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {brand.topModels.map((model, idx) => (
                  <tr key={idx} className={idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>
                    <td className="px-6 py-4 text-sm font-medium text-gray-900">
                      {model.description}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-500">
                      {model.sku || 'N/A'}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-500">
                      {model.units}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-500">
                      {formatCurrency(model.revenue)}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-500">
                      {formatCurrency(model.avgPrice)}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      );
    }
    
    return (
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        {topBrands.map((brand) => (
          <div 
            key={brand.brand} 
            className="border rounded p-3 cursor-pointer hover:bg-blue-50"
            onClick={() => setSelectedBrand(brand.brand)}
          >
            <h3 className="font-semibold text-md mb-2">{brand.brand}</h3>
            <div className="text-sm">
              <div className="font-medium mb-1">Top Models</div>
              {brand.topModels.slice(0, 2).map((model, idx) => (
                <div key={idx} className="flex flex-col mb-2">
                  <div className="truncate max-w-full font-medium" title={model.description}>
                    {model.description}
                  </div>
                  <div className="flex justify-between">
                    <span className="text-xs text-gray-500">Units: {model.units}</span>
                    <span>{formatCurrency(model.revenue)}</span>
                  </div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    );
  };
  
  // Attachments Section
  const AttachmentsSection = () => {
    if (selectedCategory) {
      const category = attachments.find(c => c.name === selectedCategory);
      
      return (
        <div>
          <div className="mb-4">
            <button 
              onClick={() => setSelectedCategory(null)} 
              className="text-blue-600 hover:underline flex items-center mb-2"
            >
              ← Back to all categories
            </button>
            <h3 className="font-semibold text-lg">
              {selectedCategory} Products with Mattress Purchases
            </h3>
          </div>
          
          <div className="overflow-auto">
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Product
                  </th>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    SKU
                  </th>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Units Sold
                  </th>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Revenue
                  </th>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Avg Price
                  </th>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Attachment Rate
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {category.topProducts.map((product, idx) => (
                  <tr key={idx} className={idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>
                    <td className="px-6 py-4 text-sm font-medium text-gray-900">
                      {product.description}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-500">
                      {product.sku || 'N/A'}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-500">
                      {product.count}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-500">
                      {formatCurrency(product.revenue)}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-500">
                      {formatCurrency(product.avgPrice)}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-500">
                      {product.attachmentRate}%
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      );
    }
    
    return (
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        {attachments.map((category) => (
          <div 
            key={category.name} 
            className="border rounded p-3 cursor-pointer hover:bg-blue-50"
            onClick={() => setSelectedCategory(category.name)}
          >
            <h3 className="font-semibold text-md mb-2">{category.name}</h3>
            <div className="text-sm">
              <div className="font-medium mb-1">Top Products</div>
              {category.topProducts.slice(0, 2).map((product, idx) => (
                <div key={idx} className="flex flex-col mb-2">
                  <div className="truncate max-w-full font-medium" title={product.description}>
                    {product.description}
                  </div>
                  <div className="flex justify-between">
                    <span className="text-xs text-gray-500">{product.attachmentRate}% with Mattress</span>
                    <span>{formatCurrency(product.revenue)}</span>
                  </div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    );
  };
  
  // Header with file info and change file button
  const DashboardHeader = () => {
    return (
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-blue-800">Mattress Sales Dashboard</h1>
        <div className="flex items-center gap-4">
          <div className="text-sm text-gray-600">
            <FileSpreadsheet className="inline h-4 w-4 mr-1" />
            {uploadedFile?.name || 'No file loaded'}
          </div>
          <button
            onClick={() => {
              setShowOnboarding(true);
              setUploadedFile(null);
              setFileData(null);
              setAllData([]);
              setFilteredData([]);
            }}
            className="px-3 py-1 text-sm bg-gray-200 hover:bg-gray-300 rounded"
          >
            Change File
          </button>
        </div>
      </div>
    );
  };
  
  // Load data when file data is available
  useEffect(() => {
    const loadData = async () => {
      if (!fileData) return;
      
      try {
        setIsLoading(true);
        setError(null);
        
        // Basic processing
        const products = processData(fileData);
        setAllData(products);
        
        // Determine available date range from the data
        const dataDateRange = findAvailableDateRange(products);
        setAvailableDateRange(dataDateRange);
        
        // Set initial date range to the available range
        setDateRange({
          startDate: dataDateRange.startDate,
          endDate: dataDateRange.endDate
        });
        
        // Apply initial date filter
        const filtered = filterByDateRange(products, dataDateRange.startDate, dataDateRange.endDate);
        setFilteredData(filtered);
        
        // Generate metrics and analysis
        analyzeData(filtered);
        
        setIsLoading(false);
      } catch (err) {
        console.error("Error loading data:", err);
        setError("Failed to process data: " + err.message);
        setIsLoading(false);
      }
    };
    
    loadData();
  }, [fileData]);
  
  // Show onboarding if no file is loaded
  if (showOnboarding) {
    return <OnboardingScreen />;
  }
  
  return (
    <div className="bg-gray-50 min-h-screen p-4">
      {isLoading ? (
        <div className="flex items-center justify-center h-64">
          <p className="text-xl font-semibold text-blue-600">Processing sales data...</p>
        </div>
      ) : error ? (
        <div className="max-w-6xl mx-auto">
          <DashboardHeader />
          <div className="bg-red-100 border border-red-400 text-red-700 p-4 rounded">
            <p className="font-bold">Error processing data</p>
            <p>{error}</p>
          </div>
        </div>
      ) : (
        <div className="max-w-6xl mx-auto">
          <DashboardHeader />
          
          {/* Filters */}
          <div className="bg-white rounded-lg shadow p-4 mb-6">
            <h2 className="text-xl font-semibold mb-4">Date Range Filter</h2>
            <DateFilter />
          </div>
          
          {/* Summary Metrics */}
          <div className="bg-white rounded-lg shadow p-4 mb-6">
            <h2 className="text-xl font-semibold mb-4">Dashboard Summary</h2>
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
              <div className="bg-blue-50 p-4 rounded-lg">
                <h3 className="text-sm font-medium text-blue-800 mb-1">Total Mattress Revenue</h3>
                <p className="text-2xl font-bold text-blue-900">{formatCurrency(metrics.revenue)}</p>
              </div>
              <div className="bg-green-50 p-4 rounded-lg">
                <h3 className="text-sm font-medium text-green-800 mb-1">Mattress Units Sold</h3>
                <p className="text-2xl font-bold text-green-900">{metrics.units}</p>
              </div>
              <div className="bg-purple-50 p-4 rounded-lg">
                <h3 className="text-sm font-medium text-purple-800 mb-1">Average Mattress Price</h3>
                <p className="text-2xl font-bold text-purple-900">{formatCurrency(metrics.avgPrice)}</p>
              </div>
              <div className="bg-orange-50 p-4 rounded-lg">
                <h3 className="text-sm font-medium text-orange-800 mb-1">Attachment Rate</h3>
                <p className="text-2xl font-bold text-orange-900">{metrics.attachmentRate.toFixed(1)}%</p>
              </div>
            </div>
          </div>
          
          {/* Top Mattresses */}
          <div className="bg-white rounded-lg shadow p-4 mb-6">
            <h2 className="text-xl font-semibold mb-4">Top Mattresses by Brand</h2>
            {topBrands.length === 0 ? (
              <p className="text-gray-500">No mattress data available for the selected date range.</p>
            ) : (
              <TopBrandsSection />
            )}
          </div>
          
          {/* Attachment Rate Analysis */}
          <div className="bg-white rounded-lg shadow p-4 mb-6">
            <h2 className="text-xl font-semibold mb-4">Attachment Rate Analysis</h2>
            {attachments.length === 0 ? (
              <p className="text-gray-500">No attachment data available for the selected date range.</p>
            ) : (
              <div className="h-64">
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart data={attachments}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="name" />
                    <YAxis yAxisId="left" orientation="left" stroke="#8884d8" />
                    <YAxis yAxisId="right" orientation="right" stroke="#82ca9d" />
                    <Tooltip 
                      formatter={(value, name) => {
                        if (name === 'rate') return `${value}%`;
                        return name === 'revenue' ? formatCurrency(value) : value;
                      }}
                    />
                    <Legend />
                    <Bar yAxisId="left" dataKey="rate" name="Attachment Rate %" fill="#8884d8" />
                    <Bar yAxisId="right" dataKey="revenue" name="Revenue" fill="#82ca9d" />
                  </BarChart>
                </ResponsiveContainer>
              </div>
            )}
          </div>
          
          {/* Top Attachment Products */}
          <div className="bg-white rounded-lg shadow p-4 mb-6">
            <h2 className="text-xl font-semibold mb-4">Top Attachment Products By Category</h2>
            {attachments.length === 0 ? (
              <p className="text-gray-500">No attachment product data available for the selected date range.</p>
            ) : (
              <AttachmentsSection />
            )}
          </div>
          
          <div className="text-center text-gray-500 text-sm mt-8">
            <p>Date range: {dateRange.startDate instanceof Date ? dateRange.startDate.toLocaleDateString() : 'N/A'} to {dateRange.endDate instanceof Date ? dateRange.endDate.toLocaleDateString() : 'N/A'}</p>
            <p className="mt-1">Available date range: {availableDateRange.startDate instanceof Date ? availableDateRange.startDate.toLocaleDateString() : 'N/A'} to {availableDateRange.endDate instanceof Date ? availableDateRange.endDate.toLocaleDateString() : 'N/A'}</p>
            <p className="mt-1">Total products: {allData.length} | Filtered products: {filteredData.length}</p>
          </div>
        </div>
      )}
    </div>
  );
};

export default MattressDashboard;
